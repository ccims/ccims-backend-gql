#The root API types

"""
All queries
"""
type Query {
    """
    Requests an object (node) using the given ID. If the given ID is invalid an error will be returned
    """
    node (
        """
        The ID of the node to return. This can't be empty or null
        """
        id: ID!
    ): Node

    """
    Requests projects in this instance of ccims
    """
    projects(
        """
        Returns projects after the given edge
        """
        after: String, 
        """
        Returns projects before the given edge
        """
        before: String,
        """
        Only projects matching this filter will be returned
        """
        filterBy: ProjectFilter, 
        """
        Only return the first _n_ projects in the system
        """
        first: Int, 
        """
        Only return the last _n_ projects in the system
        """
        last: Int
    ): ProjectPage

}

type Mutation {
    createIssue(input: CreateIssueInput!): CreateIssuePayload
    addIssueComment(input: AddIssueCommentInput!): AddIssueCommentPayload
    deleteIssueComment(input: DeleteIssueCommentInput!): DeleteIssueCommentPayload
    linkIssue(input: LinkIssueInput!): LinkIssuePayload
    unlinkIssue(input: UnlinkIssueInput!): UnlinkIssuePayload
    addLabel(input: AddLabelInput!): AddLabelPayload
    removeLabel(input: RemoveLabelInput!): RemoveLabelPayload
    pinIssue(input: PinIssueInput!): PinIssuePayload
    unpinIssue(input: UnpinIssueInput!): UnpinIssuePayload
    renameIssueTitle(input: RenameIssueTitleInput!): RenameIssueTitlePayload
    changeIssueCategory(input: ChangeIssueCategoryInput!): ChangeIssueCategoryPayload
    addAssignee(input: AddAssigneeInput!): AddAssigneePayload
    removeAssignee(input: RemoveAssigneeInput!): RemoveAssigneePayload
    closeIssue(input: CloseIssueInput!): CloseIssuePayload
    reopenIssue(input: ReopenIssueInput!): ReopenIssuePayload
    changeIssuePriority(input: ChangeIssuePriorityInput!): ChangeIssuePriorityPayload
    changeIssueStartDate(input: ChangeIssueStartDateInput!): ChangeIssueStartDatePayload
    changeIssueDueDate(input: ChangeIssueDueDateInput!): ChangeIssueDueDatePayload
    changeIssueEstimatedTime(input: ChangeIssueEstimatedTimeInput!): ChangeIssueEstimatedTimePayload
    addIssueToLocation(input: AddIssueToLocationInput!): AddIssueToLocationPayload
    removeIssueFromLocation(input: RemoveIssueFromLocationInput!): RemoveIssueFromLocationPayload
    addIssueToComponent(input: AddIssueToComponentInput!): AddIssueToComponentPayload
    removeIssueFromComponent(input: RemoveIssueFromComponentInput!): RemoveIssueFromComponentPayload
    markIssueAsDuplicate(input: MarkIssueAsDuplicateInput!): MarkIssueAsDuplicatePayload
    unmarkIssueAsDuplicate(input: UnmarkIssueAsDuplicateInput!): UnmarkIssueAsDuplicatePayload
    addReaction(input: AddReactionInput!): AddReactionPayload
    removeReaction(input: RemoveReactionInput!): RemoveReactionPayload
}

#----------Basic types---------------
"""
An object which can be identified by an ID - called a node
"""
interface Node {
    """
    The ID of this node. Every node will have an non-empty and non-null edge.

    If this is ever empty or null, something went wrong.
    """
    id: ID!
}

"""
A page (sometimes also called connection) of multiple elements. 

A page has a content (the list of elements) of some type (depending on the type of page).
It also has information about the page as well as a count of total elements of that type (not only the ones on this page)
"""
interface Page {
    pageInfo: PageInfo!
    totalCount: Int!
}

type PageInfo {
    startCursor: String
    endCursor: String
    endID: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}


#----------------------------------User---------------------------------
type User implements Node {
    id: ID!
    username: String!
    displayName: String
    email: String!
    projects(after: String, before: String, filterBy: ProjectFilter, first: Int, last: Int): ProjectPage
    assignedToIssues(after: String, before: String, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    participantOfIssues(after: String, before: String, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    issueComments(after: String, before: String, filterBy: IssueCommentFilter, first: Int, last: Int): IssueCommentPage
}

type UserPage implements Page {
    nodes: [User]
    edges: [UserEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type UserEdge {
    node: User
    cursor: String!
}

"""
Filter for a user of the system. All parameters given in this filter will be connected via _AND_
"""
input UserFilter {
    """
    Any of the strings must match the users username
    """
    username: [String!]
    """
    The users username must match this given __RegEx__
    """
    displayName: String
    """
    The mail address of the user must match any of the ones given
    """
    email: [String!]
    """
    The user must be member of at least one of the projects with the given ids
    """
    projects: [ID!]
    """
    The user must be assigned to at least one of the issues with the given ids
    """
    assignedToIssues: [ID!]
    """
    The user must be participant of at least one of the issues with the given ids
    """
    participantOfIssues: [ID!]
    """
    The user must have written at least one of the comments with the given ids
    """
    issueComments: [ID!]
}

#-----------------------------Project--------------------------

type Project implements Node {
    id: ID!
    name: String!
    components(after: String, before: String, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
    users(after: String, before: String, filterBy: UserFilter, first: Int, last: Int): UserPage
    owner: User!
    issues(after: String, before: String, filterBy: IssueFilter, first: Int, last: Int): IssuePage
}

type ProjectPage implements Page {
    nodes: [Project]
    edges: [ProjectEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ProjectEdge {
    node: Project
    cursor: String!
}

"""
Data input for creating a new project
"""
input CreateProjectInput {
    """
    The display name for the project
    """
    name: String!
    """
    The ids of all components initially part of this project
    """
    components: [ID!]
    """
    The ids of all users which are part of this project. If not given, the owner user will be added automatically
    """
    users: [ID!]
    """
    The id of the owner user
    """
    owner: ID!
}

"""
Filter for a Project. All parameters given in this filter will be connected via _AND_
"""
input ProjectFilter {
    """
    The name of the project must match any of the given strings
    """
    name: [String!]
    """
    The project must have any of the components with the given ids
    """
    components: [ID!]
    """
    At least one of the users with the given ids must be part of the project
    """
    users: [ID!]
    """
    The Owner of the project must be a user with one of the given ids
    """
    owner: [ID!]
    """
    At least one of the issues given must be on a component assigned to the project
    """
    issues: [ID!]
}


#------------------------------Component------------------------------
type Component implements Node {
    id: ID!
    name: String!
    owner: User
    description: String
    issues(after: String, before: String, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    projects(after: String, before: String, filterBy: ProjectFilter, first: Int, last: Int): ProjectPage
    interfaces(after: String, before: String, filterBy: ComponentInterfaceFilter, first: Int, last: Int): ComponentInterfacePage
    consumedInterfaces(after: String, before: String, filterBy: ComponentInterfaceFilter, first: Int, last: Int): ComponentInterfacePage
    imsType: IMSType!
    imsData: JSON!
}

type ComponentPage implements Page {
    nodes: [Component]
    edges: [ComponentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ComponentEdge {
    node: Component
    cursor: String
}

input ComponentFilter {
    name: String
}

type ComponentInterface implements Node {
    id: ID!
    name: String!
    owner: User!
    description: String
    component: Component!
    consumedBy(after: String, before: String, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
}

type ComponentInterfacePage {
    nodes: [ComponentInterface]
    edges: [ComponentInterfaceEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ComponentInterfaceEdge {
    node: ComponentInterface
    cursor: String
}

"""
Filters for an instance of a component's interface
"""
input ComponentInterfaceFilter {
    """
    The name the component has to have
    """
    name: String
    """
    Filter for interfacs owned by the user with this id
    """
    owner: ID
    """
    A Regex which the description of the interface needs to match
    """
    description: String
    """
    Filter for The ID of the component the inerface is offered by
    """
    component: ID
    """
    If given, only interfaces which are consumed by at least one of the components with the given ids can match the filter
    """
    consumedBy: [ID!]
}


#-----------------------------------Issue----------------------------------
type Issue implements Comment & Node {
    id: ID!
    title: String!
    components(after: String, before: String, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
    body: String
    bodyRendered: String
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    updatedAt: Date
    isOpen: Boolean!
    isDuplicate: Boolean!
    category: IssueCategory!
    issueComments(after: String, before: String, filterBy: IssueCommentFilter, first: Int, last: Int): IssueCommentPage
    linkedIssues(after: String, before: String, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    reactions(after: String, before: String, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    assignees(after: String, before: String, filterBy: UserFilter, first: Int, last: Int): UserPage
    labels(after: String, before: String, filterBy: LabelFilter, first: Int, last: Int): LabelPage
    participants(after: String, before: String, filterBy: UserFilter, first: Int, last: Int): UserPage
    pinnedOn(after: String, before: String, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
    timeline(after: String, before: String, filterBy: IssueTimelineItemFilter, first: Int, last: Int): IssueTimelineItemPage
    locations(after: String, before: String, filterBy: IssueLocationFilter, first: Int, last: Int): IssueLocationPage
    currentUserCanEdit: Boolean!
    currentUserCanComment: Boolean!
    startDate: Date
    dueDate: Date
    estimatedTime: TimeSpan
    spentTime: TimeSpan
}

input CreateIssueInput {
    title: String!
    body: String
    componentIDs: [ID!]!
    category: IssueCategory
    labels: [ID!]
    assignees: [ID!]
    locations: [ID!]
    startDate: Date
    dueDate: Date
    estimatedTime: TimeSpan
    clientMutationID: String
}

type CreateIssuePayload {
    clientMutationID: String
    issue: Issue
}

type IssuePage implements Page {
    nodes: [Issue]
    edges: [IssueEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueEdge {
    node: Issue
    cursor: String
}

"""
Filters for Issues. All parameters given in this filter will be connected via _AND_

Not specific issues in issue management systems but the issue in the ccims
"""
input IssueFilter {
    """
    The title of the issue must match any of the given strings
    """
    title: [String!]
    """
    The issue must be on at least one of the components with the given ids
    """
    components: [ID!]
    """
    The body text of this issue must match this given __RegEx__
    """
    body: String
    """
    The id of the user creating the issue must be any of the given ones
    """
    createdBy: [ID!]
    """
    The id of the user last editing the issue must match any of the ones in the list
    """
    editedBy: [ID!]
    """
    The issue must have been created __after__ the given date (inclusive)
    """
    createdAfter: Date
    """
    The issue must have been created __before__ the given date (inclusive)
    """
    createdBefore: Date
    """
    The issue must have been last edited __after__ the given date (inclusive)
    """
    editedAfter: Date
    """
    The issue must have been last edited __before__ the given date (inclusive)
    """
    editedBefore: Date
    """
    The last event in this issue must have occurred __after__ the given date (inclusive)
    """
    updatedAfter: Date
    """
    The last event in this issue must have occurred __before__ the given date (inclusive)
    """
    updatedBefore: Date
    """
    If given, filters for opened/closed issues
    """
    isOpen: Boolean
    """
    If given, filters for issues which are/aren't duplicates of another issue
    """
    isDuplicate: Boolean
    """
    The issue must have any of the given categories to match the filter
    """
    category: [IssueCategory!]
    """
    The issue must have at least one of the issues with the given ids
    """
    linkedIssues: [ID!]
    """
    The issue (body text) must have all the reactions in one of the lists given.
    """
    reactions: [[String!]!]
    """
    Any of the users with the given ids must be an assignee to the issue for it to match this filter
    """
    assignees: [ID!]
    """
    The issue must have all the labels of at least that are matched by at least one of the given label filters
    """
    labels: [LabelFilter!]
    """
    Any of the users with the given ids must be a participant to the issue for it to match this filter
    """
    participants: [ID!]
    """
    The issue must be assigned to at least one of the locations with the given ids
    """
    locations: [ID!]
    """
    If given filters for issues the current user is allowed/not allowed to edit (the title and body text)
    """
    currentUserCanEdit: Boolean
    """
    If given filters for issues the current user is allowed/not allowed to write new comments on
    """
    currentUserCanComment: Boolean
    """
    Filters for all issues that have a start date __after__ the give date
    """
    startDateAfter: Date
    """
    Filters for all issues that have a start date __before__ the give date
    """
    startDateBefore: Date
    """
    Filters for all issues that have a due date __after__ the give date
    """
    dueDateAfter: Date
    """
    Filters for all issues that have a due date __before__ the give date
    """
    dueDateBefore: Date
    """
    Matches all issues that have an estimated time __greater or equal__ than the given one
    """
    estimatedTimeGreaterThan: TimeSpan
    """
    Matches all issues that have an estimated time __lower or equal__ than the given one
    """
    estimatedTimeLowerThan: TimeSpan
    """
    Matches all issues that have an actual spent time __greater or equal__ than the given one
    """
    spentTimeGreaterThan: TimeSpan
    """
    Matches all issues that have an actual spent time __lower or equal__ than the given one
    """
    spentTimeLowerThan: TimeSpan
}


#------------------------------------------Issue timeline items---------------------------------------

interface IssueTimelineItem {
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type IssueTimelineItemPage implements Page {
    nodes: [IssueTimelineItem]
    edges: [IssueTimelineItemEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueTimelineItemEdge {
    node: IssueTimelineItem
    cursor: String
}

"""
Filters for certain timeline events. All parameters given in this filter will be connected via _AND_

__Please note:__ It's currently __not__ possible to filter for specific properties of an event. Might be added in future
"""
input IssueTimelineItemFilter {
    """
    Filters for the creator user of the timeline event. The id of the user must match any of the given ids
    """
    createdBy: [ID!]
    """
    The timeline event must have occurred __after__ the given date to match the filter
    """
    createdAfter: Date
    """
    The timeline event must have occurred __before__ the given date to match the filter
    """
    createdBefore: Date
}

#------------------------------------------IssueComment--------------------------------------------
interface Comment {
    id: ID!
    createdBy: User
    editedBy: [User]
    createdAt: Date!
    lastEditedAt: Date
    body: String
    bodyRendered: String
    reactions(after: String, before: String, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

input AddReactionInput {
    clientMutationID: String
    reactionToAdd: String!
}

type AddReactionPayload {
    clientMutationID: String
    reaction: ReactionGroup
    reactionEdge: ReactionGroupEdge
}

input RemoveReactionInput {
    clientMutationID: String
    reactionToRemove: String!
}

type RemoveReactionPayload {
    clientMutationID: String
}

type IssueComment implements IssueTimelineItem & Comment & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: String, before: String, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

input AddIssueCommentInput {
    body: String!
    clientMutationID: String
    issueID: ID!
}

type AddIssueCommentPayload {
    comment: IssueComment
    clientMutationID: String
    commentEdge: IssueCommentEdge
    timelineEdge: IssueTimelineItemEdge
}

type IssueCommentPage implements Page {
    nodes: [IssueComment]
    edges: [IssueCommentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueCommentEdge {
    node: IssueComment
    cursor: String
}

"""
Filter for comments on issues (not including the issue bodies themselves). All parameters given in this filter will be connected via _AND_
"""
input IssueCommentFilter {
    """
    The id of the issue the comment belongs to must match any of the given ids
    """
    issue: [ID!]
    """
    The id of the user creating the comment. Must match any one of the given ids
    """
    createdBy: [ID!]
    """
    The id of the user who __last__ edited the comment must match any of the given ids
    """
    editedBy: [ID!]
    """
    Match all comments created after the given date (inclusive)
    """
    createdAfter: Date
    """
    Match all comments created before the given date (inclusive)
    """
    createdBefore: Date
    """
    Match all comments last edited after the given date (inclusive)
    """
    editedAfter: Date
    """
    Match all comments last edited before the given date (inclusive)
    """
    editedBefore: Date
    """
    The body of a comment must match this __RegEx__ to match the filter
    """
    body: String
    """
    A comment must have all the reactions in one of the lists given.
    """
    reactions: [[String!]!]
    """
    If given, filters for comments which the user either has or hasn't got edit permissions
    """
    currentUserCanEdit: Boolean
}

type DeletedIssueComment implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    deletedBy: User
    deletedAt: Date
}

input DeleteIssueCommentInput {
    clientMutationID: String
    issueComment: ID
}

type DeleteIssueCommentPayload {
    clientMutationID: String
    deletedComment: DeletedIssueComment
    timelineEdge: IssueTimelineItemEdge
}

#when mentioned in a commit or a pull request
type ReferencedByOtherEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    component: Component
    source: String
    sourceURL: String
}

type ReferencedByIssueEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    mentionedAt: Issue
    mentionedInComment: IssueComment
}

#when an user actively links another issue
type LinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedIssue: Issue
}

input LinkIssueInput {
    clientMutationID: String,
    issue: ID!
    issueToLink: ID!
}

type LinkIssuePayload {
    clientMutationID: String
    linkedIssue: Issue
    linkedIssueEdge: IssueEdge
    timelineEdge: IssueTimelineItemEdge
}

# when an user unlinks another issue
type UnlinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLinkedIssue: Issue
}

input UnlinkIssueInput {
    clientMutationID: String,
    issue: ID!
    issueToUnlink: ID!
}

type UnlinkIssuePayload {
    clientMutationID: String
    unlinkedIssue: Issue
    timelineEdge: IssueTimelineItemEdge
}

#when another issue links this issue
type WasLinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedBy: Issue
}

#when another issue unlinks this issue
type WasUnlinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    unlinkedBy: Issue
}

type LabelledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    label: Label!
}

input AddLabelInput {
    clientMutationID: String
    issue: ID!
    label: ID!
}

type AddLabelPayload {
    clientMutationID: String
    label: Label
    issue: Issue
    event: LabelledEvent
    labelEdge: LabelEdge
    timelineEdge: IssueTimelineItemEdge
}

type UnlabelledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLabel: Label!
}

input RemoveLabelInput {
    clientMutationID: String
    issue: ID!
    label: ID!
}

type RemoveLabelPayload {
    clientMutationID: String
    label: Label
    issue: Issue
    event: UnlabelledEvent
    timelineEdge: IssueTimelineItemEdge
}

type PinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input PinIssueInput {
    clientMutationID: String
    issue: ID!
    component: ID!
}

type PinIssuePayload {
    clientMutationID: String
    pinnedIssue: Issue
    component: Component
    event: PinnedEvent
    timelineEdge: IssueTimelineItemEdge
}

type UnpinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input UnpinIssueInput {
    clientMutationID: String
    issue: ID!
    component: ID!
}

type UnpinIssuePayload {
    clientMutationID: String
    unpinnedIssue: Issue
    component: Component
    event: UnpinnedEvent
    timelineEdge: IssueTimelineItemEdge
}

type RenamedTitleEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldTitle: String!
    newTitle: String!
}

input RenameIssueTitleInput {
    clientMutationID: String
    issue: ID!
    newTitle: String!
}

type RenameIssueTitlePayload {
    clientMutationID: String
    issue: Issue
    event: RenamedTitleEvent
    timelineEdge: IssueTimelineItemEdge
}

type CategoryChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldCategory: IssueCategory!
    newCategory: IssueCategory!
}

input ChangeIssueCategoryInput {
    clientMutationID: String
    issue: ID!
    newCategory: IssueCategory!
}

type ChangeIssueCategoryPayload {
    clientMutationID: String
    issue: Issue
    event: CategoryChangedEvent
    timelineEdge: IssueTimelineItemEdge
}

type AssignedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    assignee: User!
}

input AddAssigneeInput {
    clientMutationID: String
    issue: ID!
    userToAssign: ID!
}

type  AddAssigneePayload {
    clientMutationID: String
    issue: Issue
    assignee: User
    event: AssignedEvent
    assigneeEdge: UserEdge
    timelineEdge: IssueTimelineItemEdge
}

type UnassignedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedAssignee: User!
}

input RemoveAssigneeInput {
    clientMutationID: String
    issue: ID!
    userToUnassign: ID!
}

type  RemoveAssigneePayload {
    clientMutationID: String
    issue: Issue
    unassignedUser: User
    event: UnassignedEvent
    timelineEdge: IssueTimelineItemEdge
}

type ClosedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input CloseIssueInput {
    clientMutationID: String
    issueToClose: ID!
}

type CloseIssuePayload {
    clientMutationID: String
    closedIssue: Issue
    event: ClosedEvent
    timelineEdge: IssueTimelineItemEdge
}

type ReopenedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input ReopenIssueInput {
    clientMutationID: String
    issueToReopen: ID!
}

type ReopenIssuePayload {
    clientMutationID: ID!
    reopenedIssue: Issue
    event: ReopenedEvent
    timelineEdge: IssueTimelineItemEdge
}

type PriorityChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldPriority: Priority
    newPriority: Priority
}

input ChangeIssuePriorityInput {
    clientMutationID: String
    issue: ID!
    newPriority: Priority!
}

type ChangeIssuePriorityPayload {
    clientMutationID: String
    issue: Issue
    event: PriorityChangedEvent
    timelineEdge: IssueTimelineItemEdge
}

type StartDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldStartDate: Date
    newStartDate: Date
}

input ChangeIssueStartDateInput {
    clientMutationID: String
    issue: ID!
    newStartDate: Date!
}

type ChangeIssueStartDatePayload {
    clientMutationID: String
    issue: Issue
    event: StartDateChangedEvent
    timelineEdge: IssueTimelineItemEdge
}

type DueDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldDueDate: Date
    newDueDate: Date
}

input ChangeIssueDueDateInput {
    clientMutationID: String
    issue: ID!
    newDueDate: Date!
}

type ChangeIssueDueDatePayload {
    clientMutationID: String
    issue: Issue
    event: DueDateChangedEvent
    timelineEdge: IssueTimelineItemEdge
}

type EstimatedTimeChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldEstimatedTime: TimeSpan
    newEstimatedTime: TimeSpan
}

input ChangeIssueEstimatedTimeInput {
    clientMutationID: String
    issue: ID!
    newEstimatedTime: TimeSpan!
}

type ChangeIssueEstimatedTimePayload {
    clientMutationID: String
    issue: Issue
    event: EstimatedTimeChangedEvent
    timelineEdge: IssueTimelineItemEdge
}

type AddedToLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    location: IssueLocation!
}

input AddIssueToLocationInput {
    clientMutationID: String
    issue: ID!
    locationToAdd: ID!
}

type AddIssueToLocationPayload {
    clientMutationID: String
    issue: Issue
    addedLocation: IssueLocation
    event: AddedToLocationEvent
    locationEdge: IssueLocationEdge
    timelineEdge: IssueTimelineItemEdge
}

type RemovedFromLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLocation: IssueLocation!
}

input RemoveIssueFromLocationInput {
    clientMutationID: String
    issue: ID!
    locationToRemove: ID!
}

type RemoveIssueFromLocationPayload {
    clientMutationID: String
    issue: Issue
    removedLocation: IssueLocation
    event: RemovedFromLocationEvent
    timelineEdge: IssueTimelineItemEdge
}

type AddedToComponentEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    component: Component!
}

input AddIssueToComponentInput (
    clientMutationID: String
    issue: ID!
    componentToAdd: ID!
)

type AddIssueToComponentPayload (
    clientMutationID: String
    issue: Issue
    addedComponent: Component
    event: AddedToComponentEvent
    componentEdge: ComponentEdge
    timelineEdge: IssueTimelineItemEdge
)

type RemovedFromComponentEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedComponent: Component!
}

input RemoveIssueFromComponentInput {
    clientMutationID: String
    issue: ID!
    componentToRemove: ID!
}

type RemoveIssueFromComponentPayload {
    clientMutationID: String
    issue: Issue
    removedComponent: Component
    event: RemovedFromComponentEvent
    timelineEdge: IssueTimelineItemEdge
}

type MarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    originalIssue: Issue
}

input MarkIssueAsDuplicateInput {
    clientMutationID: String
    issue: ID!
    originalIssue: ID!
}

type MarkIssueAsDuplicatePayload {
    clientMutationID: String
    issue: Issue
    originalIssue: Issue
    event: MarkedAsDuplicateEvent
    timelineEdge: IssueTimelineItemEdge
}

type UnmarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input UnmarkIssueAsDuplicateInput {
    clientMutationID: String
    issue: ID!
}

type UnmarkIssueAsDuplicatePayload {
    clientMutationID: String
    issue: Issue
    event: MarkedAsDuplicateEvent
    timelineEdge: IssueTimelineItemEdge
}



type ReactionGroup implements Node {
    users: [User]
    reaction: String!
}

type ReactionGroupPage {
    nodes: [ReactionGroup]
    edges: [ReactionGroupEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ReactionGroupEdge {
    node: ReactionGroup
    cursor: String
}

"""
A filter for reaction groups (a reaction together with the users who reacted). All parameters given in this filter will be connected via _AND_
"""
input ReactionGroupFilter {
    """
    The reactions name must match any one or more of the given strings
    """
    reaction: [String!]
    """
    A list of Users who reacted. Any reaction group which contains at least one of the given users will match the filter
    """
    users: [ID!]
}

type Label implements Node {
    id: ID!
    name: String!
    description: String
    colour: Colour
}

type LabelPage {
    nodes: [Label]
    edges: [LabelEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type LabelEdge {
    node: Label
    cursor: String
}

"""
A Filter data input for labels.  All parameters given in this filter will be connected via _AND_
"""
input LabelFilter {
    """
    A lists of names. The label needs to match any one or more of these.
    """
    name: [String!]
    """
    The __RegEx__ the description of the label needs to match
    """
    description: String

    """
    A list of label colours. Any one or more of the given colours need to match the labels colour.
    """
    colour: [Colour!]
}

#-------------------------------------Scalars and enums------------------------------------

"""
The type of the Issue management system. Currently only GitHub and ccims internal are available
"""
enum IMSType {
    """
    ccims itself is the only IMS for the component, there is no external IMS
    """
    CCIMS
    """
    GitHub (or GitHub enterprise server) is the IMS for the component
    """
    GITHUB
}

"""
The Priority which an issue has - how urgent it needs to be resolved
"""
enum Priority {

    """
    The issue has a low priority but higher than issues without priority
    """
    LOW,
    """
    The issue has a priority higher than low bot is not absolutely urgent
    """
    MEDIUM,
    """
    Issues with this priority are __very__ urgent and need to be resolved quickly
    """
    HIGH
}

"""
The category of an issue. The issue will be displayed accordingly in the ccims
"""
enum IssueCategory {

    """
    If an issue is classified _bug_ it describes an error, flaw or fault in one ore multiple component(s) or interface(s)
    """
    BUG,

    """
    If an issue is defined a _feature request_, it describes a functionality that is to be implemented at some point
    """
    FEATURE_REQUEST,

    """
    The category for issues, that either weren't yet assigned to a category or that don't fit into one of the other categories
    """
    UNCLASSIFIED
}

"""
The type of a timeline item/event so it can be filtered for <sup>(because GraphQL doesn't allow to filter for a type)</sup>
"""
enum IssueTimelineItemType {
    """
    A still visible comment on an issue (not including the actual issue text)
    """
    ISSUE_COMMENT,

    """
    A comment that has been deleted by a user. This will contain no text etc., but a message should be shown in place of the comment stating that this is a deleted comment
    """
    DELETED_ISSUE_COMMENT,

    """
    An event when this issue was referenced by an element in an IMS that is not an issue (e.g. in a commit message, pull request etc.)
    """
    REFERENCED_BY_OTHER_EVENT,

    """
    An event when this issue was referenced by an other issue in an IMS or the ccims itself
    """
    REFERENCED_BY_ISSUE_EVENT,

    """
    A link from this issue to another issue was created
    """
    LINK_EVENT,

    """
    A link from this issue to another issue was removed
    """
    UNLINK_EVENT,

    """
    An event if this issue was linked to in another issue
    """
    WAS_LINKED_EVENT,

    """
    An event if the link from another issue to this one was removed
    """
    WAS_UNLINKED_EVENT,


    """
    A label was added to this issue
    """
    LABELLED_EVENT,

    """
    A label was removed from tis issue
    """
    UNLABELLED_EVENT,

    """
    This issue was pinned as important issue in the ccims.
    __This event won't be synced along all subscribed issue management systems__
    """
    PINNED_EVENT,

    """
    This issue was unpinned in the ccims.
    __This event won't be synced along all subscribed issue management systems__
    """
    UNPINNED_EVENT,

    """
    Occurs if the title of the issue has been changed
    """
    RENAMED_TITLE_EVENT,

    """
    An event if the category (see `enum IssueCategory`) of the issue has been changed
    """
    CATEGORY_CHANGED_EVENT,

    """
    If a user has been assigned as responsible person for this issue
    """
    ASSIGNED_EVENT,

    """
    If a user has been unassigned from this issue and is no longer responsible
    """
    UNASSIGNED_EVENT,

    """
    Happens if the issue has been closed by anybody
    """
    CLOSED_EVENT,

    """
    Happens if the issue has been reopened after being closed by anybody.

    _This event doesn't occur on the first opening of the issue_
    """
    REOPENED_EVENT,

    """
    If the issue priority was changed (see `enum Priority`)
    """
    PRIORITY_CHANGED_EVENT,

    """
    An event if the date the issue gets relevant/starts has changed
    """
    START_DATE_CHANGED_EVENT,

    """
    An event if the date the issue is due on/must be finished by was changed
    """
    DUE_DATE_CHANGED_EVENT,

    """
    The estimated time required to resolve this issue was updated
    """
    ESTIMATED_TIME_CHANGED_EVENT,

    """
    Event if the cross component issue was added to another location (another component/another)
    """
    ADDED_LOCATION_EVENT,

    """
    Event if the cross component issue was removed from a location (another component/another)
    """
    REMOVED_LOCATION_EVENT,

    """
    Occurs if this issue was marked as duplicate of some other issue which is known to the ccims.
    
    (if the issue in unknown to the ccims at time of marking it as a duplicate; it's not guaranteed, that the mark will be synced)
    """
    MARKED_AS_DUPLICATE_EVENT,

    """
    An event if the issue is no longer a duplicate of another issue
    """
    UNMARKED_AS_DUPLICATE_EVENT,
}

"""
The `Date` scalar is a sting containing a date in a format compatible with _ISO-8601_

Example: `"2011-10-10T14:48:00"`
"""
scalar Date

"""
A integer number representing the length of the time span in milliseconds

Example: `60000` (equivalent to a time span of one minute)
"""
scalar TimeSpan

"""
A scalar type representing a colour in RGB colour space.
The scalar must be a string in CSS Colour Hex format: 
`#rrggbb` where `rr`, `gg`, `bb` are the hex values between _0_ and _ff_

Example: `#ffff00` (would be a _beautiful_ yellow)
"""
scalar Colour

"""
The `JSON`scalar is a string in the a JSON format
Example: `{"numbers"`: [1,2,3,4]}`
"""
scalar JSON

#--------------------------------Union types-------------------------------------------------
union IssueLocation = Component | ComponentInterface

type IssueLocationPage {
    nodes: [IssueLocation]
    edges: [IssueLocationEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueLocationEdge {
    node: IssueLocation
    cursor: String
}

input IssueLocationFilter {
    name: String
}